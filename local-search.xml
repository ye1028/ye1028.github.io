<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="Tcp-x2F-IP网络模型有哪几层"><a href="#Tcp-x2F-IP网络模型有哪几层" class="headerlink" title="Tcp&#x2F;IP网络模型有哪几层"></a>Tcp&#x2F;IP网络模型有哪几层</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层结构</title>
    <link href="/2022/08/09/%E7%BC%93%E5%AD%98/Redis%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    <url>/2022/08/09/%E7%BC%93%E5%AD%98/Redis%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis常见数据类型和应用场景"><a href="#Redis常见数据类型和应用场景" class="headerlink" title="Redis常见数据类型和应用场景"></a>Redis常见数据类型和应用场景</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>String是最基本的key-value结构,key是唯一标志,value是具体的值,value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>String的底层数据结构实现主要是SDS和int,SDS是用C语言封装的一个类,它相较于C语言的字符串有以下不同</p><ul><li><p><strong>SDS不仅可以保存文本数据还可以保存二进制数据</strong></p></li><li><p><strong>SDS获取字符串的复杂度为O（1）</strong>。c语言的字符串并不会记录自己的长度,SDS用len属性记录了字符串长度，所以复杂度为O（1）</p></li><li><p><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题</p></li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>储存对象</p></li><li><p>常规计算</p></li><li><p>分布式锁</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>List是简单的字符串列表，按照插入顺序排序，可以从头部或尾部插入元素</p><h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><p>List类型的底层数据结构是由<code>&lt;mark&gt;双向链表或压缩列表&lt;/mark&gt;</code>实现的</p><ul><li><p>如果列表的元素个数小于512个,列表每个元素的值都小于64字节，Redis会使用压缩列表作为List类型的底层数据结构</p></li><li><p>如果不满足以上的条件,Redis使用双向链表</p></li></ul><p>在Redis3.2之后,List底层结构就只由quicklist实现了，取消了双向链表和压缩列表</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>消息队列</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Hash是一个键值对集合,其中Value的形式如：value&#x3D;[{field1,value1},{field2,value2}].Hash特别适合用于存储对象。</p><h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h4><p>Hash类型的底层结构是由<mark>Hash表或压缩列表</mark>实现的：</p><ul><li><p>如果hash类型元素个数小于512个，所有值小于64字节，Hash采用压缩列表作为底层结构</p></li><li><p>不满足，则使用Hash表作为底层结构</p></li></ul><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>例如商城的购物车</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>Set是一个无序且唯一的键值对集合，它的存储顺序不会按照插入的先后顺序进行存储。一个集合最多可以存储2^32-1个元素，概念和数学中的集合类似，可以进行并集、差集、交集</p><blockquote><p>Set类型和List类型的区别</p></blockquote><ul><li><p>List可以存储重复元素，Set只能存储非重复元素</p></li><li><p>List是按照元素的先后顺序存储元素的，而Set则是无序</p></li></ul><h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><p>Set类型的底层结构是由<mark>哈希表或整数集合</mark>实现的：</p><ul><li><p>如果集合中的元素都是整数且元素个数小于512个，Redis会使用整数集合作为底层结构</p></li><li><p>不满足，则使用哈希表作为底层结构</p></li></ul><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>点赞</p></li><li><p>共同关注：利用交集</p></li><li><p>抽奖：利用去重</p></li></ul><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><p>Zset的底层数据结构是由<mark>压缩列表或者跳表</mark>实现的</p><ul><li><p>如果有序集合的元素个数小于128个，并且每个元素的值都小于64字节时，压缩列表会作为底层结构</p></li><li><p>如果不满足以上的条件，那么使用跳表作为底层结构</p></li></ul><p>在Redis7.0中,压缩列表数据结构已经彻底废弃了，交由Listpack数据结构来实现</p><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>排行榜</p></li><li><p>电话、姓名排序</p></li></ul><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p><h4 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h4><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p><blockquote><p>签到统计</p></blockquote><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p><p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p><p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p><p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETBIT</span> uid:sign:<span class="hljs-number">100</span>:<span class="hljs-number">202206</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>第二步，检查该用户 6 月 3 日是否签到。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GETBIT</span> uid:sign:<span class="hljs-number">100</span>:<span class="hljs-number">202206</span> <span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure><p>第三步，统计该用户在 6 月份的签到次数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BITCOUNT</span> uid:sign:<span class="hljs-number">100</span>:<span class="hljs-number">202206</span><br></code></pre></td></tr></table></figure><p>这样，我们就知道该用户在 6 月份的签到情况了。</p><blockquote><p> 判断用户登陆态</p></blockquote><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p><p>只需要一个 key &#x3D; login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。 50000 万 用户只需要 6 MB 的空间。</p><p>假如我们要判断 ID &#x3D; 10086 的用户的登陆情况：</p><p>第一步，执行以下指令，表示用户已登录。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETBIT</span> login_status <span class="hljs-number">10086</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GETBIT</span> login_status <span class="hljs-number">10086</span><br></code></pre></td></tr></table></figure><p>第三步，登出，将 offset 对应的 value 设置成 0。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETBIT</span> login_status <span class="hljs-number">10086</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><p>连续签到用户总数 </p></blockquote><p>如何统计出这连续 7 天连续打卡用户总数呢？</p><p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p><p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p><p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p><p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit &#x3D; 1 的个数便得到了连续打卡 3 天的用户总数了。</p><p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p><ul><li><code>opration</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li></ul><p>举个例子，比如将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 与操作</span><br><span class="hljs-keyword">BITOP </span><span class="hljs-keyword">AND </span>destmap <span class="hljs-keyword">bitmap:01 </span><span class="hljs-keyword">bitmap:02 </span><span class="hljs-keyword">bitmap:03</span><br><span class="hljs-keyword"></span><span class="hljs-comment"># 统计 bit 位 =  1 的个数</span><br><span class="hljs-keyword">BITCOUNT </span>destmap<br></code></pre></td></tr></table></figure><p>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8&#x2F;8&#x2F;1024&#x2F;1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h4 id="键值对数据库是怎么实现的"><a href="#键值对数据库是怎么实现的" class="headerlink" title="键值对数据库是怎么实现的"></a>键值对数据库是怎么实现的</h4><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统</title>
    <link href="/2022/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>计算机是由各种外部硬件设备组成的,比如内存、cpu、硬件,如果每个应用程序都要和这些硬件设备对接通信协议,这样太过于繁琐,所以出现了内核这个中间人.<mark>让内核作为应用程序和硬件设备的</mark>,这样应用设备程序只需要关心与内核交互,不用关心硬件的细节.</p><blockquote><p>内核有哪些能力?</p></blockquote><p>现代的操作系统,内核一般会提供四个基本能力:</p><ul><li><p>管理进程、线程,决定哪个进程、线程使用CPU,也就是进程调度的能力</p></li><li><p>管理内存,决定内存的分配和回收</p></li><li><p>管理硬件设备,为进程与硬件设备之间提供通信能力</p></li><li><p>提供系统调用,如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</p></li></ul><blockquote><p>内核是怎么工作的?</p></blockquote><p>内核具有很高的权限,它可以控制CPU、内存、硬件等硬件,儿应用程序的权限很低,因此大部分操作系统把内存分为两个区域:</p><ul><li><p>内核空间:这个内存空间只有内核程序可以访问</p></li><li><p>用户空间:这个内存空间专门给应用程序使用</p></li></ul><p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。</p><p>应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：</p><img src="/img/imgs/systemcall.png"><p>内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。</p><h3 id="LINUX的设计"><a href="#LINUX的设计" class="headerlink" title="LINUX的设计"></a>LINUX的设计</h3><p>Linux内核设计的理念主要有以下几点:</p><ul><li><p>MultiTask:多任务</p><ul><li><p>并行、并发的能力</p><ul><li><p>单核CPU下:让每个线程执行一小段时间,切换到下一个线程.在宏观下一段时间内执行了多个任务,这被称为并发.</p></li><li><p>多核CPU,多个任务被不同CPU核心同时执行</p></li></ul></li></ul></li><li><p>SMP:对称多处理</p><ul><li>代表每个CPU的地位是相同的,多个CPU共享同一个内存,每个CPU都可以访问完整的内存和硬件资源</li></ul></li><li><p>ELF:可执行文件链接格式</p><ul><li>可执行文件的存储格式</li></ul></li><li><p>Monolithic Kernel:宏内核</p><ul><li><p>宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</p></li><li><p>与宏内核相反的是**<mark>微内核</mark>**，微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。</p></li><li><p>还有一种内核叫<strong>混合类型内核</strong>，它的架构有点像微内核，内核里面会有一个最小版本的内核，然后其他模块会在这个基础上搭建，然后实现的时候会跟宏内核类似，也就是把整个内核做成一个完整的程序，大部分服务都在内核中，这就像是宏内核的方式包裹着一个微内核。</p></li></ul></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="为什么要有虚拟内存"><a href="#为什么要有虚拟内存" class="headerlink" title="为什么要有虚拟内存"></a>为什么要有虚拟内存</h3><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>了解虚拟内存之前,我们先认识一下什么是物理内存.</p><p>所谓物理内存就是:内存中的地址,如过直接操作物理内存的话,那么像在内存中同时运行两个程序是不可能的,如果它们同时操作内存值为2000的值那么第一个操作完后第二个将会擦掉上一个储存的所有数据.</p><blockquote><p>操作系统如何解决这个问题?</p></blockquote><p>让操作系统为每一个进程分配独立的一套虚拟地址,人人都有,大家玩自己的地址就行,互补干涉.</p><p><mark>注:操作系统会提供一种机制,将不同进程的虚拟地址和不同内存的物理地址映射起来.</mark></p><p>如果程序要访问虚拟地址的时候,由操作系统转换成不同的物理地址,这样不同的进程运行的时候,写入的是不同的物理地址,这样就不会冲突了.</p><p>于是,这里就引出了两种地址的概念:</p><ul><li><p>我们程序所使用的内存地址叫做<mark>虚拟内存地址</mark></p></li><li><p>实际存在硬件里面的空间地址叫<mark>物理内存地址</mark></p></li></ul><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存</p><blockquote><p>操作系统是如何管理虚拟地址与物理地址之间的关系？</p></blockquote><ul><li><p>内存分段</p></li><li><p>内存分页</p></li></ul><h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>程序是由若干个逻辑分段组成的,如可由代码分段、数据分段、栈段、堆段组成.<mark>不同的段是由不同的属性的,所以就用分段的形式把这些分离出来</mark>.</p><blockquote><p>分段机制下,虚拟地址和物理地址是如何映射的?</p></blockquote><p>分段机制下的虚拟地址由两部分组成,<mark>段选择因子</mark>和<mark>段内偏移量</mark></p><p>段选择因子和段内偏移量：</p><ul><li><p>段选择因子:</p><ul><li><p>段号：用作段表的索引</p></li><li><p>特权等标志位</p></li></ul></li><li><p>段内偏移量：应该位于0和段界限之间</p></li><li><p>段表：</p><ul><li><p>段内描述符</p><ul><li><p>段基地址：</p></li><li><p>段界限</p></li><li><p>特权级DPL</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2022/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2022/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="认识各个硬件部件"><a href="#认识各个硬件部件" class="headerlink" title="认识各个硬件部件"></a>认识各个硬件部件</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器是计算机中存储数据的地方以二进制的形式进行存储。在存储器中它是由一个个存储单元组成的,每个存储单元都有一个个编号，称为地址。存储器中所有的存储单元的总数称为<mark>存储容量</mark>。一般存储器是由半导体构成,但是半导体存储器的储存容量毕竟有限,因此计算机中又配置了容量更大的磁盘存储器,简称外存,半导体存储器简称<mark>内存</mark></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>控制器是计算机中发号施令的部件，相当于人类的大脑。它控制计算机各个部件有条不紊的进行工作。</p><blockquote><p>32位CPU和64位CPU得区别</p></blockquote><ul><li><p>32位可以一次计算四个字节</p></li><li><p>64位可以一次计算八个字节</p></li></ul><blockquote><p>CPU内部组件</p></blockquote><ul><li><p>控制器：相当于大脑，发号施令</p></li><li><p>计算器：用于进行逻辑计算，如加减乘除</p></li><li><p>寄存器：用于储存计算时得数据。</p><ul><li>注：既然有内存为何还要有寄存器？答：由于CPU离内存较远,比较消耗时间</li></ul></li></ul><blockquote><p>寄存器的种类</p></blockquote><ul><li><p>通用寄存器：用于存放进行计算的数据，比如需要进行加和运算的两个数据</p></li><li><p>程序计数器：用于储存CPU要执行下一条指令【<mark>所在内存地址</mark>】</p></li><li><p>指令寄存器：用来存放程序计数器指向的指令</p></li></ul><blockquote><p>计算器</p></blockquote><p>运算器只能完成加减乘除及其他一些辅助操作。对于比较复杂的，计算机在运行前必须化为一步一步简单的加减乘除等基本操作。每一个基本操作叫做一条指令,而解决某一问题的一串指令序列，叫做该问题的计算程序，简称程序。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于CPU和内存以及其它设备之间的通信，总线可分为三种：</p><ol><li><p>地址总线：用于指定CPU将要操作的内存地址</p></li><li><p>数据总线：用于读写内存的数据</p></li><li><p>控制总线：用于发送和接受信号，比如中断、设备复位等信号</p></li></ol><p>当CPU要读写内存数据的时候,一般需要通过以下三个总线：</p><ul><li><p>首先要通过【地址总线】来指定内存的地址</p></li><li><p>然后通过【控制总线】控制是读还是写命令</p></li><li><p>最后通过【数据总线】来传输数据</p></li></ul><h3 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h3><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p><h2 id="程序执行的基本过程"><a href="#程序执行的基本过程" class="headerlink" title="程序执行的基本过程"></a>程序执行的基本过程</h2><p>程序实际上就是一条一条指令,所以程序的运行就是把每一条指令一步一步的执行起来,负责执行指令的就是CPU了。</p><img src="/img/imgs/CPU执行程序.png"><p>CPU执行程序的过程如下：</p><ol><li><p>CPU首先通过<mark>程序计数器</mark>中获取下一条指令的内存地址，然后CPU的<mark>控制单元</mark>操作<mark>地址总线</mark>指定需要访问的内存地址,接着通知内存设备准备数据,数据准备好后通过[<mark>数据总线</mark>]将指令数据传给CPU,CPU收到内存传过来的数据后，将这个指令数据存入到【<mark>指令寄存器中</mark>】</p></li><li><p>CPU分析<mark>指令寄存器</mark>中的指令，确定指令的类型和参数,如果是计算类型的指令,就把指令交给<mark>逻辑计算单元</mark>运算,如果是存储类型的指令,则交给<mark>控制单元</mark>执行</p></li><li><p>CPU执行完指令后,<mark>程序计数器</mark>的值自增,表示指向下一条指令</p></li></ol><p>简单总结一下：CPU首先从程序计数器获取指令的地址，从内存中找到把需要执行的指令放入指令寄存器中，然后CPU分析指令、执行，程序计数器根据指令长度自增然后开始获取下一个指令</p><p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="指令的形式"><a href="#指令的形式" class="headerlink" title="指令的形式"></a>指令的形式</h4><p>指令由以下两个部分组成：</p><ul><li><p>操作码：告诉控制器进行什么操作</p></li><li><p>地址码：告诉控制器储存在哪个位置</p></li></ul><p>现代大多数CPU都是用流水线得方式来执行指令。所谓流水线就是把一个任务拆分为多个小任务,于是一条指令通常分为四个阶段,称为4级流水线：</p><ol><li><p>CPU通过程序计数器来读取对应内存地址得指令,这个部分称为Fetch（取得指令）</p></li><li><p>CPU对指令进行解码,这个部分称为Decode(指令译码)</p></li><li><p>CPU执行指令,这个部分称为Execution(取得指令)</p></li><li><p>CPU将计算结果存回寄存器或者将寄存器得值存入内存,这个部分称为Store（数据回写）</p></li></ol><p>上面得四个阶段,我们称为指令周期</p><p>这四个阶段是由计算机中的不同组件完成的：</p><ul><li><p>取指令的阶段：我们的指令是存放在<mark>储存器</mark>里的,实际上，通过程序计数器和指令寄存器取出指令的过程，是由<strong>控制器</strong>操作的；</p></li><li><p>指令的译码阶段过程,也是由<mark>控制器</mark>进行的</p></li><li><p>指令执行的过程，无论是进行算术操作、逻辑操作，还是进行数据传输、条件分支操作，都是由<strong>算术逻辑单元</strong>操作的，也就是由<strong>运算器</strong>处理的。但是如果是一个简单的无条件地址跳转，则是直接在<strong>控制器</strong>里面完成的，不需要用到运算器。</p></li></ul><h2 id="磁盘和内存的比较"><a href="#磁盘和内存的比较" class="headerlink" title="磁盘和内存的比较"></a>磁盘和内存的比较</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>我们想象中一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。</p><p>就是这么一个小小的场景，已经把计算机的存储结构基本都涵盖了。</p><p>我们可以把CPU比做成我们的大脑,大脑正在思考东西,好比CPU中的<mark>寄存器</mark>，处理速度是最快的，但是能存储的数据也是最小的，毕竟我们不能同时思考太多的事情。</p><p>计算机中的<mark>CPU Cache</mark> 可以比作我们大脑中的记忆,处理速度相较于寄存器较慢，但是能储存的数据也稍微多了一些。</p><p>CPU Cache通常分为<mark>L1 L2 L3</mark>三层，其中L1 Cache分为指令缓存和数据缓存，L1是离CPU最近的，因此它的速度是三个中最快的，但同时空间也是最小的。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2&#x2F;L3 Cache。</p><p>寄存器和CPU CACHE都是在CPU内部，跟CPU挨着很近，因此它们的读写速度都相当快，但是能储存的数据量很少。</p><p>我们再看看CPU外部的储存器。</p><p>当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比<strong>内存</strong>，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比<strong>硬盘</strong>，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。</p><img src="/img/imgs/学习与存储层次关系.png"><blockquote><p>储存器的分类</p></blockquote><ul><li><p>寄存器</p></li><li><p>CPU Cache</p><ul><li><p>L1 Cache</p></li><li><p>L2 Cache</p></li><li><p>L3 Cache</p></li></ul></li><li><p>内存</p></li><li><p>固态、机械硬盘</p></li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>存储器的数量通常在几十到几百之间,每个寄存器用来储存一定的字节数据比如：</p><ul><li><p>32位CPU中大多数寄存器可以储存4个字节的数据</p></li><li><p>64位CPU中大多数寄存器可以储存8个字节的数据</p></li></ul><p>寄存器的速度非常快，一般要求半个CPU时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1&#x2F;2G，也就是 0.5ns（纳秒）。</p><h4 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h4><img src="/img/imgs/CPU-Cache.png"><p>CPU Cache用的是一种叫<strong>SRAM（<em>Static Random-Access</em> Memory，静态随机存储器）</strong> 的芯片.</p><p>之所以叫静态随机存储器,是因为它只要保持通电的情况下，数据就会一直存在，如果断电数据就会销毁。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 <strong>DRAM （<em>Dynamic Random Access Memory</em>，动态随机存取存储器）</strong> 的芯片。</p><p>相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。</p><p>DRAM 存储一个 bit 数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p><h4 id="SSD-x2F-HDD-硬盘"><a href="#SSD-x2F-HDD-硬盘" class="headerlink" title="SSD&#x2F;HDD 硬盘"></a>SSD&#x2F;HDD 硬盘</h4><p>SSD就是固态硬盘,结构和内存类似，但是它相比内存的优点是断电后数据还是存在的。</p><h3 id="存储器的层层次关系"><a href="#存储器的层层次关系" class="headerlink" title="存储器的层层次关系"></a>存储器的层层次关系</h3><img src="/img/imgs/存储器的层次关系图.png"><p><strong>每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构</strong></p><h5 id="存储器之间的实际价格和性能差距"><a href="#存储器之间的实际价格和性能差距" class="headerlink" title="存储器之间的实际价格和性能差距"></a>存储器之间的实际价格和性能差距</h5><table><thead><tr><th>存储器</th><th>硬件介质</th><th>成本</th><th>随机访问延时</th></tr></thead><tbody><tr><td>L1</td><td>SRAM</td><td>7</td><td>1ns</td></tr><tr><td>L2</td><td>SRAM</td><td>7</td><td>4ns</td></tr><tr><td>Memory</td><td>DRAM</td><td>0.015</td><td>100ns</td></tr><tr><td>Disk</td><td>SSD</td><td>0.0004</td><td>150μs</td></tr><tr><td>Disk</td><td>HDD</td><td>0.00004</td><td>10ms</td></tr></tbody></table><h2 id="如何写出让CPU跑的更快的代码"><a href="#如何写出让CPU跑的更快的代码" class="headerlink" title="如何写出让CPU跑的更快的代码"></a>如何写出让CPU跑的更快的代码</h2><h3 id="CPU-Cache的数据结构和读取过程是什么样的"><a href="#CPU-Cache的数据结构和读取过程是什么样的" class="headerlink" title="CPU Cache的数据结构和读取过程是什么样的"></a>CPU Cache的数据结构和读取过程是什么样的</h3><p>CPU Cache的数据是从内存中读取过来的，它是一小块一小块读取数据的，而不是单个数组元素来读取数据，在CPU Cache中，这样一小块一小块的数据叫做<mark>Cache Line（缓存块）</mark></p><p>打比方L1 Cache Line大小64字节，也就意味着L1 Cache<mark>一次载入数据的大小是64字节</mark>。</p><p>有一个int array[100]的数组,当载入array[0]时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会<strong>顺序加载</strong>数组元素到 <code>array[15]</code>，意味着 <code>array[0]~array[15]</code> 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。</p><h2 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h2><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>现在的CPU都是多核的,由于L1、L2都是各个CPU肚子拥有的,那么会带来缓存一致性的问题。</p><p>例如：两个线程同时操作I++;由于计算机为了性能，使用了写回策略,先把值为1的执行结果写入到L1、L2缓存中并把相应的Block标记为脏数据,这个时候数据并没有被同步到内存中因为写回策略，只有在 A 号核心中的这个 Cache Block 要被替换的时候，数据才会写入到内存里。</p><p>这时候第二个线程去内存中获取数据，将读取到错误的值。这就是缓存一致性问题.A和B缓存不一致,从而导致执行结果的错误.</p><p>那么，要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：</p><ol><li><p>某个CPU核心里的Cache数据更新时,必须要传播到其他核心的Cache,这个称为<mark>写传播</mark></p></li><li><p>某个CPU核心里对数据的操作顺序,必须在其他核心看起来顺序一样,这个称为<mark>事物的串行化</mark></p></li></ol><p>第二个我们举个例子来理解:</p><p>假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量 i（初始值为 0 ）。A 号核心先把 i 值变为 100，而此时同一时间，B 号核心先把 i 值变为 200，这里两个修改，都会「传播」到 C 和 D 号核心。</p><p>那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量 i 是先变成 100，后变成 200。</p><p>而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量 i 先变成 200，再变成 100，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。</p><p>所以，我们要保证 C 号核心和 D 号核心都能看到<strong>相同顺序的数据变化</strong>，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串行化。</p><h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p>写传播的原则就是当某个CPU核心更新了Cache中的数据,要把该事件广播通知到其他核心.最常见的实现方式就是<mark>总线嗅探</mark></p><p>总线嗅探方法很简单,CPU需要每时每刻监听总线上的一切活动,但是不管别的核心的Cache是否缓存相同的数据,都要发出一个广播事件.</p><p><mark>注:总线嗅探不能保证事务串行化</mark></p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>MESI基于总线嗅探实现了事务串行化,也用状态机制减低了总线带宽压力</p><p>MESI是四个状态单词的开头字母:</p><ul><li><p><em>Modified</em>:已修改</p><ul><li>就是之前说的脏数据,代表缓存已更新但是还没有同步到内存中</li></ul></li><li><p><em>Exclusive</em>:独有</p><ul><li>数据只存储在一个 CPU 核心的 Cache 里</li></ul></li><li><p><em>Shared</em>:共享</p><ul><li>数据只存储在多个 CPU 核心的 Cache 里</li></ul></li><li><p><em>Invalidated</em>:失效</p><ul><li>代表Cache Block里的数据已经失效了,不可以读取该状态</li></ul></li></ul><p>注:独有和共享都是数据干净的.</p><p>我们举个具体的例子来看看这四个状态的转换：</p><ol><li>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；</li><li>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；</li><li>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。</li><li>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。</li><li>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring总结</title>
    <link href="/2022/07/13/%E6%A1%86%E6%9E%B6/Spring%E6%BA%90%E7%A0%81/"/>
    <url>/2022/07/13/%E6%A1%86%E6%9E%B6/Spring%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring运行流程"><a href="#Spring运行流程" class="headerlink" title="Spring运行流程"></a>Spring运行流程</h1><h3 id="Spring中一些前置知识"><a href="#Spring中一些前置知识" class="headerlink" title="Spring中一些前置知识"></a>Spring中一些前置知识</h3><h4 id="如何设置容器"><a href="#如何设置容器" class="headerlink" title="如何设置容器"></a>如何设置容器</h4><p>通常设置容器有以下几种方式：</p><ol><li><p>通过xml配置文件配置Bean</p></li><li><p>通过注解得形式配置Bean</p></li></ol><h4 id="何为BeanDefinition"><a href="#何为BeanDefinition" class="headerlink" title="何为BeanDefinition"></a>何为BeanDefinition</h4><p>BeanDefinition是Bean的信息定义类,它包含着Bean的一些如是否单例、scope作用域、是否懒加载等信息</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;<br><br>    <span class="hljs-type">String</span> SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;<br><br>    <span class="hljs-type">String</span> SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;<br><br>    <span class="hljs-type">int</span> ROLE_APPLICATION = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> ROLE_SUPPORT = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> ROLE_INFRASTRUCTURE = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(<span class="hljs-type">String</span> parentName)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">String</span> <span class="hljs-title">getParentName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(<span class="hljs-type">String</span> beanClassName)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">String</span> <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(<span class="hljs-type">String</span> scope)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">String</span> <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> lazyInit)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="何为BeanPostProcessor"><a href="#何为BeanPostProcessor" class="headerlink" title="何为BeanPostProcessor"></a>何为BeanPostProcessor</h4><p>BeanPostProcessor是Spring提供的可以对Bean进行修改的拓展类。用户只要实现这个类并交给Spring容器来管理.那么Spring在加载的时候会默认加载并运行用户写的拓展方法。</p><p>实现BeanFactoryPostProcessor接口可以对BeanDefinitionMap中的BeanDefinition进行修改。</p><p>实现BeanDefinitionRegistryPostProcessor接口,可以实现BeanDefinition的注册。</p><p>诸如此类，不再一一举例。</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory是定义生产Bean的最高级接口.它定义了生成获取Bean等一系列方法。</p><p>ApplicationContextApplicationContext就是BeanFactory派生类,它不仅有生产Bean的功能，它还有国家化、注解等额外功能。</p><p><mark>注：</mark>注解的功能依赖于BeanPostProcessor</p><h3 id="Spring运行流程-1"><a href="#Spring运行流程-1" class="headerlink" title="Spring运行流程"></a>Spring运行流程</h3><p>Spring运行的流程主要要经过以下几个步骤：</p><ol><li><p>通过读取器(BeanDefinitionReader)读取配置文件</p></li><li><p>通过扫描器(BeanDefinitionScanner)扫描配置文件中的bean</p></li><li><p>通过注册器(BeanDefinitionRegistry)把这些bean一一注入BeanDefinitionMap中</p></li><li><p>执行BeanPostProcessor的派生类</p></li><li><p>通过BeanFactory工厂获取Bean</p></li></ol><h3 id="IOC的创建过程"><a href="#IOC的创建过程" class="headerlink" title="IOC的创建过程"></a>IOC的创建过程</h3><ol><li><p>读取器读取定义的配置类</p></li><li><p>扫描器扫描配置类的配置信息并用注册器注册进BeanDefinition(配置信息集合,存储着类的基本信息是否懒加载等等)中。</p></li><li><p>执行bean工厂的后置处理器</p></li><li><p>通过Bean工厂生成相应的实例，bean的生成可以分成以下几步<br>4.1.通过反射实例化bean<br>4.2.属性赋值<br>4.3.实现了aware会一一执行aware实现的方法<br>4.4 执行bean的后置处理器<br>4.5 执行init方法<br>4.6执行bean的后置处理器<br>4.7执行销毁的方法</p></li></ol><p>BeanFactory是最顶层的接口，它只定义了创建bean获取Bean的方法。实际上是由子类ApplicationContext来创建。ApplicationContext在BeanFactory的基础上增添了许多额外的功能,例如Bean的后置处理器(如解析注解的后置处理器)、国际化等等拓展功能。</p><p>以注解的方法为例：</p><p>1.创建的时候会优先执行父类的构造器,在父类中率先创建了bean工厂</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericApplicationContext</span>()</span> &#123;<br>   <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在执行本类的构造器,在this方法中创建了读取器(reader)和扫描器(scanner),在创建读取器的方法中,spring率先创建了一些重要的beanFactory的后置处理器(例如解析注解的后置处理器)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">public <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(Class&lt;?&gt;... componentClasses) &#123;<br> <span class="hljs-built_in">this</span>();<br> <span class="hljs-built_in">register</span>(componentClasses);<br> <span class="hljs-built_in">refresh</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>3.register方法中将配置类加载到了BeanDefinition中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">Class&lt;?&gt;... componentClasses</span>) &#123;<br>   <span class="hljs-title class_">Assert</span>.<span class="hljs-title function_">notEmpty</span>(componentClasses, <span class="hljs-string">&quot;At least one component class must be specified&quot;</span>);<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">reader</span>.<span class="hljs-title function_">register</span>(componentClasses);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.接下来就是refresh,Spring最为核心的方法,在这个方法中使用了模板模式,自定义的beanFactory的后置处理器加载和执行以及bean的后置处理器的加载和执行已经bean的创建都在此方法中实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void refresh<span class="hljs-literal">()</span> throws BeansException, IllegalStateException &#123;<br>   synchronized (this.startupShutdownMonitor) &#123;<br>      <span class="hljs-comment">// Prepare this context for refreshing.</span><br> prepare<span class="hljs-constructor">Refresh()</span>; <span class="hljs-comment">//进行环境的初始化</span><br><br> <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br> ConfigurableListableBeanFactory beanFactory = obtain<span class="hljs-constructor">FreshBeanFactory()</span>;<span class="hljs-comment">//刷新bean工厂并返回bean工厂</span><br><br> <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br> prepare<span class="hljs-constructor">BeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<span class="hljs-comment">//设置bean工厂的参数</span><br><br> <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br> post<span class="hljs-constructor">ProcessBeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br><br> <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br> invoke<span class="hljs-constructor">BeanFactoryPostProcessors(<span class="hljs-params">beanFactory</span>)</span>; **/按照优先级执行beanFactory的后置处理器并依次执行<br><br> <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br> register<span class="hljs-constructor">BeanPostProcessors(<span class="hljs-params">beanFactory</span>)</span>; <span class="hljs-comment">//注册bean的后置处理器</span><br><br> <span class="hljs-comment">// Initialize message source for this context.</span><br> init<span class="hljs-constructor">MessageSource()</span>; <span class="hljs-comment">//国际化功能</span><br><br> <span class="hljs-comment">// Initialize event multicaster for this context.</span><br> init<span class="hljs-constructor">ApplicationEventMulticaster()</span>; <span class="hljs-comment">//事件</span><br><br> <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br> on<span class="hljs-constructor">Refresh()</span>;<br><br> <span class="hljs-comment">// Check for listener beans and register them.</span><br> register<span class="hljs-constructor">Listeners()</span>;<br><br> <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br> finish<span class="hljs-constructor">BeanFactoryInitialization(<span class="hljs-params">beanFactory</span>)</span>; <span class="hljs-comment">//创建bean实例</span><br><br> <span class="hljs-comment">// Last step: publish corresponding event.</span><br> finish<span class="hljs-constructor">Refresh()</span>;<br> &#125;<br><br>      catch (BeansException ex) &#123;<br>         <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">WarnEnabled()</span>) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                  <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br> &#125;<br><br>         <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br> destroy<span class="hljs-constructor">Beans()</span>;<br><br> <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br> cancel<span class="hljs-constructor">Refresh(<span class="hljs-params">ex</span>)</span>;<br><br> <span class="hljs-comment">// Propagate exception to caller.</span><br> throw ex;<br> &#125;<br><br>      finally &#123;<br>         <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br> <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br> reset<span class="hljs-constructor">CommonCaches()</span>;<br> &#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上最核心的方法莫过于invokeBeanFactoryPostProcessors和finishBeanFactoryInitialization我们先来说一说invokeBeanFactoryPostProcessors</p><p>,通过源码可知,先从bean工厂中获取到实现了BeanDefinitionRegistryPostProcessor的类，在依依按照优先级的顺序逐个执行，debug我们可得知在此方法中会获取到开始我们注册读取器是预先注入的后置处理器中的internalConfigurationAnnotationProcessor，它最优先执行，并解析配置文件中的注解将我们配置的bean填充到bean定义中.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发篇</title>
    <link href="/2022/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%AF%87%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%AF%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h3><p>在一个时间段内多个事件同时执行，以时间片轮询的方法频繁切换线程的方式让它在一个时间段内看起来同时执行这叫做并发。常见于单核CPU</p><h3 id="什么是并行"><a href="#什么是并行" class="headerlink" title="什么是并行"></a>什么是并行</h3><p>在多CPU的时候,每个CPU各自执行一个事件，互不占用资源。在同一个时间点同时执行的叫做并行</p><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p>微观概念不同：并发多个事件在一个时间段内同时执行。并行在一个时间点同时执行。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>我们平时运行的QQ,网易云等软件就是一个进程。线程是进程的最小执行单位，可以把线程看成进程的每个子任务。例如QQ，我们在QQ上既可以聊天同时又可以下载文件这就是进程的两个线程。用一句话概括就是进程是操作系统的分配资源最小单位。线程是程序执行的最小执行单位</p><h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><ul><li><p>共享进程的资源</p><ul><li>线程有自己独立的pc计数器和栈，它们共享方法区和堆区</li></ul></li><li><p>可以并发、并行执行</p><ul><li>在一个进程的多个线程可以并发、并行执行</li></ul></li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>在java程序中，我们在Thread的源码中可得知线程有6中状态。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">public enum State &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 线程创建</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">        NEW,</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * java线程中将就绪（READY）和运行中（RUNNING）两种状态笼统的称为“运行”</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">        RUNNABLE,</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 被Synchronized、lock阻塞</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">        BLOCKED,</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 线程被阻塞如调用了wait() sleep()</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">        WAITING,</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 线程调用了带有时间的等待如wait(1000) sleep(1000)</span><br><span class="hljs-comment">         */</span><br><span class="hljs-built_in">        TIMED_WAITING,</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 终止</span><br><span class="hljs-comment">         */</span><br>        TERMINATED<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><img src="/img/imgs/state.png"><p>在操作系统的分类中，操作系统分为了五种</p><ol><li><p>新建：创建新的进程</p></li><li><p>就绪：进程已经获得除CPU时间片以外的任何资源，一旦获得cpu时间片就能立马执行。</p></li><li><p>执行：处于就绪队列中的进程获得了时间片运行进程。</p></li><li><p>阻塞：进程时间片用完进入阻塞队列中等待唤醒。</p></li><li><p>终止：进程执行完毕。</p></li></ol><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-keyword">thread</span>.setPriority(); <span class="hljs-comment">//可通过这个方式设置优先级</span><br></code></pre></td></tr></table></figure><p>cpu会根据优先级权重侧重把资源分给相应的线程，没啥卵用</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java有两种线程第一个为用户线程第二个则是守护线程,守护线程一般用来执行后台任务，例如GC回收。java虚拟机不会根据它是否执行完成而决定自己是否关闭。Java虚拟机会在所有用户线程执行完后退出</p><blockquote><p>如何设置守护线程</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>()<span class="hljs-comment">;</span><br><span class="hljs-keyword">thread</span>.setDaemon(<span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>如何判断是守护线程</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-built_in">boolean</span> daemon = <span class="hljs-keyword">thread</span>.isDaemon();<br></code></pre></td></tr></table></figure><h2 id="创建线程的多种方式"><a href="#创建线程的多种方式" class="headerlink" title="创建线程的多种方式"></a>创建线程的多种方式</h2><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-keyword">super</span>.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现Callable接口创建线程"><a href="#实现Callable接口创建线程" class="headerlink" title="实现Callable接口创建线程"></a>实现Callable接口创建线程</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Callable</span></span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        FutureTask futureTask = <span class="hljs-keyword">new</span> <span class="hljs-type">FutureTask</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyCallable</span>());<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(futureTask).start();<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> Object call() throws Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用线程池的方式创建线程"><a href="#使用线程池的方式创建线程" class="headerlink" title="使用线程池的方式创建线程"></a>使用线程池的方式创建线程</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>      <span class="hljs-title class_">ThreadPoolExecutor</span> threadPoolExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">60</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MINUTES</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br>      threadPoolExecutor.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>              <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>          &#125;<br>      &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="几种线程创建方法的不同点"><a href="#几种线程创建方法的不同点" class="headerlink" title="几种线程创建方法的不同点"></a>几种线程创建方法的不同点</h3><ul><li><p>Thread与其他几种方法相比,耦合性太大</p></li><li><p>runnable与Callable相比,没有会返回值且不能抛出异常</p></li><li><p>使用线程池会减少资源的消耗,提高复用性。线程的创建和销毁都会占用系统的资源</p></li></ul><h3 id="线程池详解"><a href="#线程池详解" class="headerlink" title="线程池详解"></a>线程池详解</h3><blockquote><p>线程池的核心参数</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">public ThreadPoolExecutor<br>(int corePoolSize, <span class="hljs-regexp">//</span>核心线程大小<br> int maximumPoolSize, <span class="hljs-regexp">//</span>线程池最大的线程数量<br> long keepAliveTime, <span class="hljs-regexp">//</span>没有任务多久销毁<br> TimeUnit unit,     <span class="hljs-regexp">//</span>时间单位<br> BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-regexp">//</span>阻塞队列<br> ThreadFactory threadFactory,   <span class="hljs-regexp">//</span>线程工厂<br> RejectedExecutionHandler handler)  <span class="hljs-regexp">//</span>拒绝策略<br></code></pre></td></tr></table></figure><blockquote><p>拒绝策略</p></blockquote><p>在Java线程池中一共有四种拒绝策略</p><ol><li><p>ThreadPoolExecutor.AbortPolicy 默认的拒绝策略，拒绝任务并且抛弃</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy 直接调用线程运行此任务</p></li><li><p>ThreadPoolExecutor.DiscardPolicy 直接抛弃任务不报错</p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy 丢弃队列中最老的任务，把此任务加入队列</p></li></ol><blockquote><p>submit()和execute()</p></blockquote><ol><li><p>点开ThreadPoolExecutor可以发现execute()没有重载方法,它只接受Runnable.而submit即可接受runnable还可接受callable。</p></li><li><p>execute()没有返回值.submit返回值Future</p></li><li><p>submit()可以通过Future.get()判断线程是否执行成功</p></li></ol><blockquote><p>线程池原理</p></blockquote><p>线程池<mark>不会开始就初始化核心线程</mark>,等请求来到时会创建相应个数的核心线程来处理请求,后续如果有额外的请求核心线程无法处理,会把请求放在阻塞队列中,如果队列也放满后。会创建非核心线程来处理。但是非核心线程<mark>使用完后会销毁</mark>。如果非核心线程也满了，则会使用拒绝策略。</p><blockquote><p>为什么不允许使用Executors</p></blockquote><p>Executors是Java提供的一个快捷创建线程池的类,它提供了四个可以创建线程池的方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<span class="hljs-comment">//由参数我们可以得知这个方法给我们提供了一个固定线程大小的线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<span class="hljs-comment">//只有一个核心线程的线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60</span>L, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-type">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<span class="hljs-comment">//没有核心线程，只有非核心线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">ScheduledThreadPool</span>(int corePoolSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<span class="hljs-comment">//创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</span><br></code></pre></td></tr></table></figure><p>那为什么不建议使用它内置的方法内：可以看阿里给出的意见如图所示：</p><img src="/img/imgs/alibaba.png"><blockquote><p>源码解析</p></blockquote><p>待完善…………………………………………………………………………………</p><h2 id="其他基础知识"><a href="#其他基础知识" class="headerlink" title="其他基础知识"></a>其他基础知识</h2><h3 id="让线程睡眠的方法"><a href="#让线程睡眠的方法" class="headerlink" title="让线程睡眠的方法"></a>让线程睡眠的方法</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>()<span class="hljs-comment">;</span><br><span class="hljs-keyword">thread</span>.wait(<span class="hljs-number">3000</span>)<span class="hljs-comment">;</span><br><span class="hljs-keyword">Thread</span>.sleep(<span class="hljs-number">3000</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>wait()和sleep()的区别</p></blockquote><ol><li><p>wait是Object的方法,sleep是来自Thread</p></li><li><p>wait会释放掉锁。</p></li></ol><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>几个线程互相占用彼此的资源,互不放开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>                      System.out.println(<span class="hljs-string">&quot;aa&quot;</span>);<br>                  &#125;<br>                  Thread.sleep(<span class="hljs-number">1000</span>);<br>                  <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>                      System.out.println(<span class="hljs-string">&quot;a拿到资源&quot;</span>);<br>                  &#125;<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>              &#125;<br>          &#125;<br>      &#125;);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>                      System.out.println(<span class="hljs-string">&quot;bb&quot;</span>);<br>                  &#125;<br>                  Thread.sleep(<span class="hljs-number">1000</span>);<br>                  <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>                      System.out.println(<span class="hljs-string">&quot;b拿到资源&quot;</span>);<br>                  &#125;<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>              &#125;<br>          &#125;<br>      &#125;);<br>      a.start();<br>      b.start();<br></code></pre></td></tr></table></figure><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><p>破环其中一个线程的必要条件</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h4><p>我们都知道访问共享资源容易产生线程安全的问题。那有没有什么方法只让它们访问自己的本地的变量呢,Java提供了一个Threadloal，它会在线程本地创建一个变量副本。</p><h3 id="ThreadLocal的实现"><a href="#ThreadLocal的实现" class="headerlink" title="ThreadLocal的实现"></a>ThreadLocal的实现</h3><img src="/img/imgs/threadlocal.png"><p>本质上就是map集合.threadlocal是工具类提供了调用的方法。实际上存放在ThreadlocalMap中。我们在使用完资源后要记得释放，不然有可能造成内存溢出问题。</p><h3 id="Java中变量的内存可见性"><a href="#Java中变量的内存可见性" class="headerlink" title="Java中变量的内存可见性"></a>Java中变量的内存可见性</h3><h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p>我们来看一看Java对共享变量访问的模型</p><img src="/img/imgs/cache.png"><ol><li><p>线程访问一个变量会先从三级缓存中逐个寻找,如果没有再去主内存中</p></li><li><p>在主内存中获取到主句,在三级缓存中逐个放入</p></li><li><p>在Cpu中进行运算之后，在缓存中把数据同步</p></li><li><p>最后把数据放入主内存中</p></li></ol><blockquote><p>会造成的问题</p></blockquote><p>由于有缓存的存在，线程会率先在缓存中获取.这样可能会造成可见性问题。例如：a,b线程在自己的缓存中都有这个数据,a对数据进行了改变同步到内存中，但是b的缓存并没有同步它会直接从自己缓存中获取以前的数据。</p><h3 id="数据同步的八大原子操作"><a href="#数据同步的八大原子操作" class="headerlink" title="数据同步的八大原子操作"></a>数据同步的八大原子操作</h3><ol><li><p>lock(锁定):线程锁定主内存的操作的变量,其他线程不能操作</p></li><li><p>unlock(解锁):线程解锁主内存的操作的变量</p></li><li><p>read(读取):把主内存的要操作的变量传输到缓存当中</p></li><li><p>load(加载):把缓存中得到的变量值放入工作内存的副本中</p></li><li><p>use(使用):把工作内存副本中的要操作的变量值传递给执行引擎</p></li><li><p>assign(赋值):把从执行引擎收到的值赋给工作内存的变量</p></li><li><p>store(存储): 把工作内存的值传入主内存中</p></li><li><p>write(写入):再把store操作的值传送到主内存的值中</p></li></ol><img src="/img/imgs/Snipaste_2022-07-13_11-10-14.png"><h3 id="java中synchronized关键字"><a href="#java中synchronized关键字" class="headerlink" title="java中synchronized关键字"></a>java中synchronized关键字</h3><h4 id="synchronized关键字介绍"><a href="#synchronized关键字介绍" class="headerlink" title="synchronized关键字介绍"></a>synchronized关键字介绍</h4><p>在多线程操作共享资源的时候可能会造成线程安全的问题。这时候我们可以使用synchronized来修饰方法或者代码块.获得锁的线程才能进行执行。其他的线程直接陷入阻塞状态。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title function_">synchronized</span> (<span class="hljs-variable language_">this</span>)&#123;<br>          <br>&#125; <span class="hljs-comment">//代码块中的代码只能有一个线程执行</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">sendGift</span><span class="hljs-params">()</span></span>&#123;<br>     <br>&#125;<span class="hljs-comment">//和上面一样只不过锁的是方法全部的代码</span><br></code></pre></td></tr></table></figure><h4 id="synchronized的内存语义"><a href="#synchronized的内存语义" class="headerlink" title="synchronized的内存语义"></a>synchronized的内存语义</h4><p>synchronized在老版本的jdk中是一个重量级锁，效率极其低下在很多情况下我们并不需要重量级锁。在现在的版本中jdk引入了一个锁升级的概念。</p><p>偏向锁-&gt;轻量级锁-&gt;重量级锁</p><blockquote><p>偏向锁</p></blockquote><p>偏向锁主要用来优化同一线程多次申请同一个锁的竞争</p><blockquote><p>轻量级锁</p></blockquote><p>在竞争少情况的时候，使用自旋锁</p><blockquote><p>重量级锁</p></blockquote><p>在竞争激烈情况的时候，使用重量级锁</p><p>注意：锁的升级不可逆</p><blockquote><p>内存语义</p></blockquote><p>synchronized的内存语义是把代码块中使用到的变量清楚。获取的时候直接从主内存中去取数据,写入数据时直接写入主内存中。</p><h3 id="Volatitle"><a href="#Volatitle" class="headerlink" title="Volatitle"></a>Volatitle</h3><p>synchronized用来解决可见性太过于笨重了.Java又提供了一个Volatitle关键字。它可以保证可见性和禁止指令重排。Volatitle在读取的时候会清除缓存中的数据。在写入的时候会写入主内存。Volatitle不能保证原子性</p><h3 id="Java的原子性操作"><a href="#Java的原子性操作" class="headerlink" title="Java的原子性操作"></a>Java的原子性操作</h3><blockquote><p>何为原子性</p></blockquote><p>原子性指的是执行一系列操作时，要么全部执行完，要么不执行。</p><blockquote><p>java中哪些可以保证原子性操作</p></blockquote><ul><li><p>synchronized和lock锁可以保证原子性</p></li><li><p>Volatitle关键字不能保证</p></li></ul><h3 id="Java中的CAS操作"><a href="#Java中的CAS操作" class="headerlink" title="Java中的CAS操作"></a>Java中的CAS操作</h3><blockquote><p>何为CAS</p></blockquote><p>在JAVA中处理并发的过程中使用锁有一个不好之处，获取不到锁的线程会陷入阻塞状态这一状态的切换会消耗大量的系统资源。这时候引入了CAS这个概念。CAS是比较与交换的缩写。它有四个关键的参数。内存的偏移量，内存的地址，旧值，新值。线程获取不到锁的时候会自旋等待占用锁的线程执行完成，而不会进行上下文切换。</p><blockquote><p>使用了CAS的类</p></blockquote><ul><li>Lock锁、AQS</li></ul><h3 id="UnSafe类"><a href="#UnSafe类" class="headerlink" title="UnSafe类"></a>UnSafe类</h3><p>unsafe是一个用来操作内存的工具包。它们使用JNI的方式访问本地C++实现库。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span>(<span class="hljs-built_in">Object</span> var1, <span class="hljs-type">long</span> var2, <span class="hljs-built_in">Object</span> var4, <span class="hljs-built_in">Object</span> var5);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span>(<span class="hljs-built_in">Object</span> var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span>(<span class="hljs-built_in">Object</span> var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">long</span> var4, <span class="hljs-type">long</span> var6);<br></code></pre></td></tr></table></figure><p>CAS的实现基于UnSafe工具包。</p><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><h4 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h4><p>为了解决系统中主内存和CPU间的速度差，操作系统引入了缓存。在主内存和CPU中间放入一级或者多级缓存,从主内存获取的数据会放在缓存中,下一次获取可直接从缓存中获取提升速度。如下图所示：</p><img src="/img/imgs/twocache.png"><blockquote><p> 那么数据在缓存中如何存储的呢？</p></blockquote><p>数据在缓存中是以块的形式存储。例如线程从主内存中获取数据A那么它取回的时候不单单只取A还会按照Cache行的大小把它旁边的BCD全部带回去把行填满。Cache行的大小一般为2的幕次数字节。</p><p>伪共享就是线程A访问A线程B访问B。由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RedisCluster</title>
    <link href="/2022/07/09/%E7%BC%93%E5%AD%98/RedisCluster/"/>
    <url>/2022/07/09/%E7%BC%93%E5%AD%98/RedisCluster/</url>
    
    <content type="html"><![CDATA[<h2 id="RedisCluster"><a href="#RedisCluster" class="headerlink" title="RedisCluster"></a>RedisCluster</h2><blockquote><p>为何有RedisCluster？</p></blockquote><ol><li><p>哨兵模式下，主节点异常后，切换主从将一台slave设置为master。这期间不能接受任何得请求。在对数据要求高的公司中这是万万不能接受的。</p></li><li><p>Redis的哨兵模式只有一个主节点对外提供写操作,没法支持很高的并发。且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步得效率。</p></li></ol><blockquote><p>何为RedisCluster</p></blockquote><p>RedisCluster结构如图所示：</p><img src="/img/imgs/RedisCluster.png"><p><mark>它与哨兵模式的区别：</mark></p><p>例如：RedisCluster它的数据是分片放的.拿上图做例子：例如10g数据RedisCluster它会把这数据分成三份分别放入不同的主节点的.它的数据是不重叠的。</p><p>它解决的痛点：</p><ol><li><p>相较于哨兵,访问瞬断(主从切换)的情况有所好转，主节点的宕机不影响其他主节点的使用.这是这个节点的暂时访问不了(主从切换)</p></li><li><p>可以缓存大量的数据解决了大并发问题,例如存入1T的数据,我们可以使用100个节点每个节点存入10G数据。RedisCluster的节点是可以横向扩容的.但是<mark>不建议节点超过1000</mark></p></li></ol><p><mark>注 ：redis集群搭建需要至少三个主节点</mark></p><p><mark>注 ：redis集群的从节点只有备份的功能,不能提供读的功能。master提供读写</mark></p><blockquote><p>Redis集群选择原理</p></blockquote><ol><li><p>当Slave节点发现自己的master服务器挂了变为了FAIL。</p></li><li><p>将自己记录的集群currentEpoch(集群的选举周期)加1，并广播对所有节点发送FAILOVER_AUTH_REQUEST信息</p></li><li><p>其他节点接收到信息后,只有master响应，判断合法性,并返回发送FAILOVER_AUTH_ACK,只返回一次,即使接收到其余子节点请求到后也不会返回</p></li><li><p>尝试成为主节点的从节点会收集其他master返回的FAILOVER_AUTH_REQUEST</p></li><li><p>slave收到<mark>超过半数master的ack</mark>后会变成新的master(这也解释了为啥需要三个主节点,如果其中一个主节点挂了，只剩一个主节点是不能选择成功的)</p></li><li><p>成为主节点的slave会广播pong通知其他集群节点,自己已经成为主节点</p></li></ol><p><mark>注：如果票数相同会重复以上操作</mark></p><blockquote><p>集群脑裂数据丢失</p></blockquote><p>redis集群没有过半机制会有脑裂问题（由于网络问题主节点和子节点连接不上。等到一定时间选择出一个新的主节点），网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。<br>解决方法</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span> <span class="hljs-comment"> //写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br></code></pre></td></tr></table></figure><blockquote><p>网络抖动</p></blockquote><p>连接突然不能访问，然后很快恢复正常。可以设置主节点和子节点之间断连时间避免脑裂的产生.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">cluster-<span class="hljs-keyword">node</span><span class="hljs-title">-timeout</span>  //在规定的时间内不会发生主从替换<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幂等性</title>
    <link href="/2022/07/08/%E9%9A%8F%E7%AC%94/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2022/07/08/%E9%9A%8F%E7%AC%94/%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>mq在发送消息的时候可能存在重复消费的问题。例如消费端消费完后还没有向mq发送缺人时突然宕机了,那么mq会认为消费还没有被消费会重新发送信息，这样会导致如数据库重复数据，数据库数据冲突，资源重复等。 </p><p>这时候我们可以引入幂等性：</p><p>每个消息接收服务，首要<mark>判断就是幂等性</mark>。幂等性通过后再处理消息。</p><p>具体方案如下：</p><ol><li>用全局的消息id来控制幂等性.在消费端我们首先先判断Redis中是否存在该信息,如果存在直接放回,如果不存在我们在消费完后把这个id存入Redis中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;<br><br>    <span class="hljs-meta">@RabbitListener(queues = QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">messageId</span> <span class="hljs-operator">=</span> message.getMessageProperties().getMessageId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;接收导的消息为：&quot;</span>+msg+<span class="hljs-string">&quot;==消息id为：&quot;</span>+messageId);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">messageIdRedis</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;messageId&quot;</span>);<br>        <span class="hljs-keyword">if</span>(messageId == messageIdRedis)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//业务逻辑省略</span><br>        .....<br>        .....<br>        jedis.set(<span class="hljs-string">&quot;messageId&quot;</span>,messageId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引入幂等性后对系统有什么影响"><a href="#引入幂等性后对系统有什么影响" class="headerlink" title="引入幂等性后对系统有什么影响"></a>引入幂等性后对系统有什么影响</h3><p>优点：</p><ul><li>使调用接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。</li></ul><p>缺点：</p><ul><li><p>增加了服务端的逻辑复杂性和成本</p></li><li><p>增加了额外控制幂等的业务逻辑，复杂化了业务功能</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Aop实现一个动态缓存</title>
    <link href="/2022/07/06/%E9%9A%8F%E7%AC%94/%E7%94%A8Aop%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98/"/>
    <url>/2022/07/06/%E9%9A%8F%E7%AC%94/%E7%94%A8Aop%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>首先我们先定义一个接口,来规定缓存的方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">CacheInterface</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">R</span>&gt; &#123;<br>    <span class="hljs-function">R <span class="hljs-title">getValue</span>(<span class="hljs-params">T key</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">T key,R <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">update</span>(<span class="hljs-params">T key,R <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">delete</span>(<span class="hljs-params">T key</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foreach</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后实现这个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheManage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CacheInterface</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Result</span>&gt;&#123;<br><br>    <span class="hljs-comment">//本地缓存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Object</span>&gt;&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Object</span>&gt; <span class="hljs-title function_">getValue</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key))&#123;<br>            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key, Result value</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key) &amp;&amp; cache.<span class="hljs-title function_">get</span>(value) != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        cache.<span class="hljs-title function_">put</span>(key,value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key, Result value</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key))&#123;<br>            cache.<span class="hljs-title function_">put</span>(key,value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key))&#123;<br>            cache.<span class="hljs-title function_">remove</span>(key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteAll</span>(<span class="hljs-params"></span>) &#123;<br>       cache.<span class="hljs-title function_">clear</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">foreach</span>(<span class="hljs-params"></span>) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OrderTask &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *key主键的值</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键的前缀</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>最关键的一步,使用Aop来实现动态缓存</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">```<br>@Component<br>@Aspect<br>public <span class="hljs-keyword">class</span> AopProcess &#123;<br>    @Autowired<br>    CacheManage cacheManage;<br><br>    @<span class="hljs-constructor">Around(<span class="hljs-string">&quot;@annotation(com.ye.interaction.friend.OrderTask)&quot;</span>)</span><br>    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;<br>        long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>        MethodSignature signature = (MethodSignature)joinPoint.get<span class="hljs-constructor">Signature()</span>;<br>        OrderTask annotation = signature.get<span class="hljs-constructor">Method()</span>.get<span class="hljs-constructor">Annotation(OrderTask.<span class="hljs-params">class</span>)</span>;<br>        <span class="hljs-comment">//没有标注此注解执行下一步</span><br>        <span class="hljs-keyword">if</span> (annotation<span class="hljs-operator"> == </span>null) &#123;<br>            return joinPoint.proceed<span class="hljs-literal">()</span>;<br>        &#125;<br>        String key = annotation.key<span class="hljs-literal">()</span>;<br>        String prefix = annotation.prefix<span class="hljs-literal">()</span>;<br>        Object proceed = joinPoint.proceed<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//没有返回值,直接返回</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">proceed</span>)</span>) &#123;<br>            return null;<br>        &#125;<br>        <span class="hljs-comment">//有返回值进行缓存</span><br>        Result&lt;Object&gt; <span class="hljs-keyword">object</span> = <span class="hljs-keyword">new</span> Result&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Result(<span class="hljs-params">proceed</span>)</span>;<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Args(<span class="hljs-params">joinPoint</span>.<span class="hljs-params">getArgs</span>()</span>);<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Name(<span class="hljs-params">signature</span>.<span class="hljs-params">getName</span>()</span>);<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Time(<span class="hljs-params">new</span> Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>        <span class="hljs-keyword">if</span>(!prefix.equals(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-operator"> || </span>!key.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            prefix = prefix.equals(<span class="hljs-string">&quot;&quot;</span>)?prefix:prefix+<span class="hljs-string">&quot;&quot;</span>;<br>            cacheManage.set<span class="hljs-constructor">Value(<span class="hljs-params">prefix</span>+<span class="hljs-params">key</span>,<span class="hljs-params">object</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cacheManage.set<span class="hljs-constructor">Value(<span class="hljs-params">signature</span>.<span class="hljs-params">getMethod</span>()</span>.get<span class="hljs-constructor">Name()</span>, <span class="hljs-keyword">object</span>);<br>        &#125;<br>        return proceed;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>储存的实体类如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt;&#123;<br>    <span class="hljs-comment">//储存的数据</span><br>    T result;<br>    <span class="hljs-comment">//输入参数</span><br>    T[] args;<br>    <span class="hljs-comment">//名称</span><br>    <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-comment">//储存的时间</span><br>    <span class="hljs-title class_">String</span> time;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResult</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setResult</span>(<span class="hljs-params">T result</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T[] <span class="hljs-title function_">getArgs</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> args;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setArgs</span>(<span class="hljs-params">T[] args</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">args</span> = args;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getTime</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> time</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span> = time;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化及主从架构</title>
    <link href="/2022/07/05/%E7%BC%93%E5%AD%98/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/07/05/%E7%BC%93%E5%AD%98/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis一般用作于应用程和数据库之间的中间层,用于储存热点数据,减轻数据库的压力,但是我们可能会遇到服务器宕机的情况,在这情况下,数据如果没备份的话,大量请求会穿过redis进入mysql中，会导致数据库压力急剧变大甚至宕机。Redis给我们提供以下几个持久化方法：</p><ul><li><p>RDB：当在规定时间内修改的次数超过配置文件中的次数会将会形成内存快照进行备份</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>   #在<span class="hljs-number">900</span>秒(<span class="hljs-number">15</span>分钟)之后，如果至少有<span class="hljs-number">1</span>个key发生变化，则dump内存快照。<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>  #在<span class="hljs-number">300</span>秒(<span class="hljs-number">5</span>分钟)之后，如果至少有<span class="hljs-number">10</span>个key发生变化，则dump内存快照。<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><ul><li><p>优点：相较于AOF恢复数据时效率较高,它文件中保存的是数据，AOF保存的是修改指令</p></li><li><p>缺点：数据不安全,数据丢失的较多</p></li></ul></li><li><p>AOF：每进行一次修改命令时,会将命令写入文件中，在文件大小时重写前的一倍时会触发重写。有几种策略可以使用：</p><ol><li><p>appendfsync always每有一个修改命令,就会记录文件中</p></li><li><p>appendfsync everysec：每隔一秒记录</p></li><li><p>appendfsync no ：由系统规定写入磁盘的时间</p><ul><li><p>优点：数据相较于RDB保存完整</p></li><li><p>缺点：效率执行缓慢</p></li></ul></li></ol></li><li><p>RDB+AOF混合：混合模式和AOF大致相同,改变的是重写(bgsave)时会把命令二进制化。</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Redis主从架构"><a href="#Redis主从架构" class="headerlink" title="Redis主从架构"></a>Redis主从架构</h2><p>Redis在运行的过程中可能会因为各种原因宕机.一旦宕机那么会导致数据库压力急剧变大甚至宕机。为了防止这种情况保证它的高可用性。我们可以尝试使用Redis的主从架构。主从不仅可以防止这种情况,它还可以分担主库的大部分压力。主从负责写,从库负责读</p><blockquote><p>如何添加主从</p></blockquote><p>我们只需要在文件中添加以下代码即可：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">replicaof <span class="hljs-number">192.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">6379</span>  //设置主节点<br><span class="hljs-keyword">replica</span>-<span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> yes     //只用于只读<br></code></pre></td></tr></table></figure><blockquote><p>主库和从库如何保证数据的一致性</p></blockquote><ol><li><p>slave从库第一次连接master主库时,会发送psync命令,在发送命令之前首先会进行socket长连接</p></li><li><p>master主库接收到命令会执行bgsave将内存中数据形成快照</p></li><li><p>将数据发送到slave从库中</p></li><li><p>slave从库会清空数据并加载RDB数据</p></li><li><p>在形成快照这过程中,其中会有新的请求进来生成新的数据（Redis生成快照时会fork出一个子线程）.Redis会将这些指令保存到缓存区中。等RDB发送完成后，紧接着发缓存区数据</p></li><li><p>slave从库会执行缓存区中的命令</p></li><li><p>在后续的过程中,主从一致性都是通过缓存区的形式传输</p></li></ol><p>如图所示：</p><img src="/img/imgs/slave.png"><blockquote><p>主从复制风暴</p></blockquote><p>一个主库同时有多个从库连接可能会造成主库压力过大,这时候我们可以选择把这些分散,</p><p>一个主库连接两个从库,其中从库也作为下面的主库,形成一个树状结构</p><h2 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h2><p>主从架构的Redis有一个致命得缺点，如果主节点发生故障之后，无法自动实现故障转移,需要手动的从slave节点中选择一个作为主节点，由此哨兵模式由此而生。</p><blockquote><p>何为哨兵</p></blockquote><p>哨兵就是一个Redis只不过他只起到监控其他Redis得作用,如果主Redis发生故障.那么它会从从库中选择一个作为主节点。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>混合设计模式在项目中的运用</title>
    <link href="/2022/07/05/%E9%9A%8F%E7%AC%94/%E6%B7%B7%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/05/%E9%9A%8F%E7%AC%94/%E6%B7%B7%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="策略-模板-工厂简化项目中的if-else"><a href="#策略-模板-工厂简化项目中的if-else" class="headerlink" title="策略+模板+工厂简化项目中的if-else"></a>策略+模板+工厂简化项目中的if-else</h2><p>最近在做开发的时候,遇到了一个需求：管理员在不同视图下观看到不同的数据</p><p>如果按照以往的开发下使用if-else,不仅在代码上看着臃肿而且还在后续的开发中也难以维护。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(name.equals(<span class="hljs-string">&quot;a&quot;</span>)</span></span>)<br>&#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(name<span class="hljs-selector-class">.equals</span>(<span class="hljs-string">&quot;b&quot;</span>))&#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(name<span class="hljs-selector-class">.equals</span>(<span class="hljs-string">&quot;c&quot;</span>)&#123;&#125;<br>.......<br></code></pre></td></tr></table></figure><ol><li><p>首先我们可以把逻辑代码抽象成一个抽象类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Handle</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">InitializingBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> AAA();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后不同逻辑代码实现这个共同的父接口</p></li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZhangSanHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Handle</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AAA</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//子类实现InitializingBean接口的afterPropertiesSet会在初始化Bean的时候执行</span><br>       Factory.register(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建一个工厂类负责生产这些类</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;<span class="hljs-built_in">String</span>,Handle&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Handle <span class="hljs-title function_">getInvokeStrategy</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">get</span>(<span class="hljs-built_in">str</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>,Handle handle)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(StringUtils.<span class="hljs-property">isEmpty</span>(<span class="hljs-built_in">str</span>) || <span class="hljs-literal">null</span> == handle)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">str</span>,handle);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此最原始的代码可以优化为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Handle a <span class="hljs-operator">=</span> Factory.getInvokeStrategy(<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment">;</span><br>a.AAA()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果逻辑代码的业务逻辑大体不同的话,如一个有返回值，一个没有返回值,那么我们只需要把handle改成模板方法即可</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类继承这个模板类实现自己相应的接口即可</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql隔离级别与锁机制</title>
    <link href="/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h3><p>事务是一组SQL语句组成的逻辑单元,事务由以下四个特性。通常被称为ACID</p><ol><li><p>原子性：语句要么全部执行成功，只要一个失败就会返回</p></li><li><p>一致性：事务完成前后，数据保持一致</p></li><li><p>隔离性：一个事务不影响另外一个事务</p></li><li><p>持久性：事务完成之后，对数据的修改是永久的</p></li></ol><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><ul><li><p>脏读：一个事务读取到了另外一个事务还没提交的数据(可能回滚)</p></li><li><p>不可重复读：一个事务中在不同时间段中相同的sql语句获取到了不同的数据</p></li><li><p>幻读：一个事务中在不同时间段中相同的sql语句获取到了个数不同的数据</p></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>乐观锁：根据版本号,如果版本号不匹配重新执行</p></li><li><p>悲观锁：在自己执行的过程中其他事务都不能操作这个数据</p><ul><li><p>表锁：操作时直接锁住整张表,其他不可访问</p></li><li><p>行锁：操作时锁住操作的数据</p></li><li><p>读锁：其他事务可以读,不可以写</p></li><li><p>写锁：不可读写</p></li></ul></li></ul><h3 id="解决并发事务问题"><a href="#解决并发事务问题" class="headerlink" title="解决并发事务问题"></a>解决并发事务问题</h3><ul><li><p>读未提交</p></li><li><p>读已提交(解决脏读)</p></li><li><p>可重复读(解决脏读、不可重复读)</p></li><li><p>串行化(解决脏读、不可重复读、幻读)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Mysql索引</title>
    <link href="/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Mysql索引"><a href="#深入理解Mysql索引" class="headerlink" title="深入理解Mysql索引"></a>深入理解Mysql索引</h1><blockquote><p>索引简介</p></blockquote><p>索引是帮助Mysql高效获取数据的<mark>排好序</mark>的<mark>数据结构</mark></p><p>索引数据结构</p><ul><li><p>hash：不能进行范围查询</p></li><li><p>红黑树</p></li></ul><p>众所周知数据都是存储在磁盘上的。在我们查询数据的时候，会进行磁盘io一条一条数据进行比对,磁盘io速度缓慢,在数据库数据量庞大的时候查询速度会极其缓慢。为了减少磁盘IO,这时候引入索引这个数据结构</p><blockquote><p>聚集索引与非聚集索引</p></blockquote><ul><li><p><mark>聚集索引</mark>：聚集索引就是索引结构和数据库数据的数据分别在同一个文件中,数据全部保存在叶子节点下面</p></li><li><p><mark>非聚集索引</mark>：和聚集索引定义相反,树结构的叶子节点保存的是该数据的磁盘位置</p></li></ul><blockquote><p>红黑树</p></blockquote><p>Mysql数据库中INNODB引擎中默认使用的索引结构是红黑树,所谓红黑树就是二叉树的变种.</p><p>为什么mysql采用红黑树的结构而不是用二叉树呢？</p><p>答：</p><ol><li><p>红黑树相较于二叉树它的非叶子节点不会储存数据</p></li><li><p>红黑树的叶子结点有指针相互引用,在范围搜索的情况下，会提升效率</p></li></ol><p><mark>特点</mark>：数据从左到右递增</p><p>结构如下：</p><p><img src="file:///C:/Users/WS/AppData/Roaming/marktext/images/2022-06-30-17-08-33-image.png" title="" alt="" width="298"><img src="file:///C:/Users/WS/AppData/Roaming/marktext/images/2022-06-30-17-09-04-image.png" title="" alt="" width="334"></p><blockquote><p>红黑树为何能提升效率</p></blockquote><p>搜索数据的时候,首先会先加载第一行的数据进入RAM（内存）中,匹配找到条件的大体位置,往下搜索,重复如上操作。由图可知,例如我们查找主键20的数据,只需要查询三次即可搜索到数据,相较于mysql的全表扫描效率提升极大。</p><blockquote><p>索引覆盖</p></blockquote><p>所谓的索引覆盖就是查询的数据在索引树中可以直接获取到，而不用回表到主键索引聚集表中查询</p><blockquote><p>回表</p></blockquote><p>在索引树中找不到需要的数据,返回到主键索引树中搜索</p><blockquote><p>索引下推</p></blockquote><p>在MYSQL5.6之前，select  * from a  where username like   “a%”  and age &#x3D; 23  在联合索引结构中进行条件搜索时，不会对索引查询的字段(age&#x3D;23)进行判断,会进行回表，在主键索引中进行条件过滤。5.6之后增加了索引下推这个概念,会先根据条件进行过滤</p><blockquote><p>联合索引</p></blockquote><p>MYSQL进行联合索引的创建时,会生成一个非聚集索引结构,默认只能有一个聚集索引即主键索引树。</p><p>例如：username , phone ,age 三个字段为一个联合索引.会先依照username进行排序,如果相等在依照phone进行排序如果相同最后才会以age进行排序.叶子节点储存着对应的id,以便进行回表查询</p><p><img src="C:\Users\WS\AppData\Roaming\marktext\images\2022-06-30-17-38-52-image.png"></p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
