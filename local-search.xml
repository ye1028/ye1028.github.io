<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RedisCluster</title>
    <link href="/2022/07/09/%E7%BC%93%E5%AD%98/RedisCluster/"/>
    <url>/2022/07/09/%E7%BC%93%E5%AD%98/RedisCluster/</url>
    
    <content type="html"><![CDATA[<h2 id="RedisCluster"><a href="#RedisCluster" class="headerlink" title="RedisCluster"></a>RedisCluster</h2><blockquote><p>为何有RedisCluster？</p></blockquote><ol><li><p>哨兵模式下，主节点异常后，切换主从将一台slave设置为master。这期间不能接受任何得请求。在对数据要求高的公司中这是万万不能接受的。</p></li><li><p>Redis的哨兵模式只有一个主节点对外提供写操作,没法支持很高的并发。且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步得效率。</p></li></ol><blockquote><p>何为RedisCluster</p></blockquote><p>RedisCluster结构如图所示：</p><img src="/img/imgs/RedisCluster.png"><p><mark>它与哨兵模式的区别：</mark></p><p>例如：RedisCluster它的数据是分片放的.拿上图做例子：例如10g数据RedisCluster它会把这数据分成三份分别放入不同的主节点的.它的数据是不重叠的。</p><p>它解决的痛点：</p><ol><li><p>相较于哨兵,访问瞬断(主从切换)的情况有所好转，主节点的宕机不影响其他主节点的使用.这是这个节点的暂时访问不了(主从切换)</p></li><li><p>可以缓存大量的数据解决了大并发问题,例如存入1T的数据,我们可以使用100个节点每个节点存入10G数据。RedisCluster的节点是可以横向扩容的.但是<mark>不建议节点超过1000</mark></p></li></ol><p><mark>注 ：redis集群搭建需要至少三个主节点</mark></p><p><mark>注 ：redis集群的从节点只有备份的功能,不能提供读的功能。master提供读写</mark></p><blockquote><p>Redis集群选择原理</p></blockquote><ol><li><p>当Slave节点发现自己的master服务器挂了变为了FAIL。</p></li><li><p>将自己记录的集群currentEpoch(集群的选举周期)加1，并广播对所有节点发送FAILOVER_AUTH_REQUEST信息</p></li><li><p>其他节点接收到信息后,只有master响应，判断合法性,并返回发送FAILOVER_AUTH_ACK,只返回一次,即使接收到其余子节点请求到后也不会返回</p></li><li><p>尝试成为主节点的从节点会收集其他master返回的FAILOVER_AUTH_REQUEST</p></li><li><p>slave收到<mark>超过半数master的ack</mark>后会变成新的master(这也解释了为啥需要三个主节点,如果其中一个主节点挂了，只剩一个主节点是不能选择成功的)</p></li><li><p>成为主节点的slave会广播pong通知其他集群节点,自己已经成为主节点</p></li></ol><p><mark>注：如果票数相同会重复以上操作</mark></p><blockquote><p>集群脑裂数据丢失</p></blockquote><p>redis集群没有过半机制会有脑裂问题（由于网络问题主节点和子节点连接不上。等到一定时间选择出一个新的主节点），网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。<br>解决方法</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span> <span class="hljs-comment"> //写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幂等性</title>
    <link href="/2022/07/08/%E9%9A%8F%E7%AC%94/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2022/07/08/%E9%9A%8F%E7%AC%94/%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>mq在发送消息的时候可能存在重复消费的问题。例如消费端消费完后还没有向mq发送缺人时突然宕机了,那么mq会认为消费还没有被消费会重新发送信息，这样会导致如数据库重复数据，数据库数据冲突，资源重复等。 </p><p>这时候我们可以引入幂等性：</p><p>每个消息接收服务，首要<mark>判断就是幂等性</mark>。幂等性通过后再处理消息。</p><p>具体方案如下：</p><ol><li>用全局的消息id来控制幂等性.在消费端我们首先先判断Redis中是否存在该信息,如果存在直接放回,如果不存在我们在消费完后把这个id存入Redis中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;<br><br>    <span class="hljs-meta">@RabbitListener(queues = QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">messageId</span> <span class="hljs-operator">=</span> message.getMessageProperties().getMessageId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;接收导的消息为：&quot;</span>+msg+<span class="hljs-string">&quot;==消息id为：&quot;</span>+messageId);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">messageIdRedis</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;messageId&quot;</span>);<br>        <span class="hljs-keyword">if</span>(messageId == messageIdRedis)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//业务逻辑省略</span><br>        .....<br>        .....<br>        jedis.set(<span class="hljs-string">&quot;messageId&quot;</span>,messageId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引入幂等性后对系统有什么影响"><a href="#引入幂等性后对系统有什么影响" class="headerlink" title="引入幂等性后对系统有什么影响"></a>引入幂等性后对系统有什么影响</h3><p>优点：</p><ul><li>使调用接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。</li></ul><p>缺点：</p><ul><li><p>增加了服务端的逻辑复杂性和成本</p></li><li><p>增加了额外控制幂等的业务逻辑，复杂化了业务功能</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Aop实现一个动态缓存</title>
    <link href="/2022/07/06/%E9%9A%8F%E7%AC%94/%E7%94%A8Aop%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98/"/>
    <url>/2022/07/06/%E9%9A%8F%E7%AC%94/%E7%94%A8Aop%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>首先我们先定义一个接口,来规定缓存的方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">CacheInterface</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">R</span>&gt; &#123;<br>    <span class="hljs-function">R <span class="hljs-title">getValue</span>(<span class="hljs-params">T key</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">T key,R <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">update</span>(<span class="hljs-params">T key,R <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">delete</span>(<span class="hljs-params">T key</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foreach</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后实现这个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheManage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CacheInterface</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Result</span>&gt;&#123;<br><br>    <span class="hljs-comment">//本地缓存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Object</span>&gt;&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Object</span>&gt; <span class="hljs-title function_">getValue</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key))&#123;<br>            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key, Result value</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key) &amp;&amp; cache.<span class="hljs-title function_">get</span>(value) != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        cache.<span class="hljs-title function_">put</span>(key,value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key, Result value</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key))&#123;<br>            cache.<span class="hljs-title function_">put</span>(key,value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">nonNull</span>(key))&#123;<br>            cache.<span class="hljs-title function_">remove</span>(key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteAll</span>(<span class="hljs-params"></span>) &#123;<br>       cache.<span class="hljs-title function_">clear</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">foreach</span>(<span class="hljs-params"></span>) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OrderTask &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *key主键的值</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键的前缀</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>最关键的一步,使用Aop来实现动态缓存</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">```<br>@Component<br>@Aspect<br>public <span class="hljs-keyword">class</span> AopProcess &#123;<br>    @Autowired<br>    CacheManage cacheManage;<br><br>    @<span class="hljs-constructor">Around(<span class="hljs-string">&quot;@annotation(com.ye.interaction.friend.OrderTask)&quot;</span>)</span><br>    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;<br>        long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>        MethodSignature signature = (MethodSignature)joinPoint.get<span class="hljs-constructor">Signature()</span>;<br>        OrderTask annotation = signature.get<span class="hljs-constructor">Method()</span>.get<span class="hljs-constructor">Annotation(OrderTask.<span class="hljs-params">class</span>)</span>;<br>        <span class="hljs-comment">//没有标注此注解执行下一步</span><br>        <span class="hljs-keyword">if</span> (annotation<span class="hljs-operator"> == </span>null) &#123;<br>            return joinPoint.proceed<span class="hljs-literal">()</span>;<br>        &#125;<br>        String key = annotation.key<span class="hljs-literal">()</span>;<br>        String prefix = annotation.prefix<span class="hljs-literal">()</span>;<br>        Object proceed = joinPoint.proceed<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//没有返回值,直接返回</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">proceed</span>)</span>) &#123;<br>            return null;<br>        &#125;<br>        <span class="hljs-comment">//有返回值进行缓存</span><br>        Result&lt;Object&gt; <span class="hljs-keyword">object</span> = <span class="hljs-keyword">new</span> Result&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Result(<span class="hljs-params">proceed</span>)</span>;<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Args(<span class="hljs-params">joinPoint</span>.<span class="hljs-params">getArgs</span>()</span>);<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Name(<span class="hljs-params">signature</span>.<span class="hljs-params">getName</span>()</span>);<br>        <span class="hljs-keyword">object</span>.set<span class="hljs-constructor">Time(<span class="hljs-params">new</span> Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>        <span class="hljs-keyword">if</span>(!prefix.equals(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-operator"> || </span>!key.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            prefix = prefix.equals(<span class="hljs-string">&quot;&quot;</span>)?prefix:prefix+<span class="hljs-string">&quot;&quot;</span>;<br>            cacheManage.set<span class="hljs-constructor">Value(<span class="hljs-params">prefix</span>+<span class="hljs-params">key</span>,<span class="hljs-params">object</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cacheManage.set<span class="hljs-constructor">Value(<span class="hljs-params">signature</span>.<span class="hljs-params">getMethod</span>()</span>.get<span class="hljs-constructor">Name()</span>, <span class="hljs-keyword">object</span>);<br>        &#125;<br>        return proceed;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>储存的实体类如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt;&#123;<br>    <span class="hljs-comment">//储存的数据</span><br>    T result;<br>    <span class="hljs-comment">//输入参数</span><br>    T[] args;<br>    <span class="hljs-comment">//名称</span><br>    <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-comment">//储存的时间</span><br>    <span class="hljs-title class_">String</span> time;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResult</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setResult</span>(<span class="hljs-params">T result</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T[] <span class="hljs-title function_">getArgs</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> args;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setArgs</span>(<span class="hljs-params">T[] args</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">args</span> = args;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getTime</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> time</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span> = time;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化及主从架构</title>
    <link href="/2022/07/05/%E7%BC%93%E5%AD%98/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/07/05/%E7%BC%93%E5%AD%98/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis一般用作于应用程和数据库之间的中间层,用于储存热点数据,减轻数据库的压力,但是我们可能会遇到服务器宕机的情况,在这情况下,数据如果没备份的话,大量请求会穿过redis进入mysql中，会导致数据库压力急剧变大甚至宕机。Redis给我们提供以下几个持久化方法：</p><ul><li><p>RDB：当在规定时间内修改的次数超过配置文件中的次数会将会形成内存快照进行备份</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>   #在<span class="hljs-number">900</span>秒(<span class="hljs-number">15</span>分钟)之后，如果至少有<span class="hljs-number">1</span>个key发生变化，则dump内存快照。<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>  #在<span class="hljs-number">300</span>秒(<span class="hljs-number">5</span>分钟)之后，如果至少有<span class="hljs-number">10</span>个key发生变化，则dump内存快照。<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><ul><li><p>优点：相较于AOF恢复数据时效率较高,它文件中保存的是数据，AOF保存的是修改指令</p></li><li><p>缺点：数据不安全,数据丢失的较多</p></li></ul></li><li><p>AOF：每进行一次修改命令时,会将命令写入文件中，在文件大小时重写前的一倍时会触发重写。有几种策略可以使用：</p><ol><li><p>appendfsync always每有一个修改命令,就会记录文件中</p></li><li><p>appendfsync everysec：每隔一秒记录</p></li><li><p>appendfsync no ：由系统规定写入磁盘的时间</p><ul><li><p>优点：数据相较于RDB保存完整</p></li><li><p>缺点：效率执行缓慢</p></li></ul></li></ol></li><li><p>RDB+AOF混合：混合模式和AOF大致相同,改变的是重写(bgsave)时会把命令二进制化。</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Redis主从架构"><a href="#Redis主从架构" class="headerlink" title="Redis主从架构"></a>Redis主从架构</h2><p>Redis在运行的过程中可能会因为各种原因宕机.一旦宕机那么会导致数据库压力急剧变大甚至宕机。为了防止这种情况保证它的高可用性。我们可以尝试使用Redis的主从架构。主从不仅可以防止这种情况,它还可以分担主库的大部分压力。主从负责写,从库负责读</p><blockquote><p>如何添加主从</p></blockquote><p>我们只需要在文件中添加以下代码即可：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">replicaof <span class="hljs-number">192.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">6379</span>  //设置主节点<br><span class="hljs-keyword">replica</span>-<span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> yes     //只用于只读<br></code></pre></td></tr></table></figure><blockquote><p>主库和从库如何保证数据的一致性</p></blockquote><ol><li><p>slave从库第一次连接master主库时,会发送psync命令,在发送命令之前首先会进行socket长连接</p></li><li><p>master主库接收到命令会执行bgsave将内存中数据形成快照</p></li><li><p>将数据发送到slave从库中</p></li><li><p>slave从库会清空数据并加载RDB数据</p></li><li><p>在形成快照这过程中,其中会有新的请求进来生成新的数据（Redis生成快照时会fork出一个子线程）.Redis会将这些指令保存到缓存区中。等RDB发送完成后，紧接着发缓存区数据</p></li><li><p>slave从库会执行缓存区中的命令</p></li><li><p>在后续的过程中,主从一致性都是通过缓存区的形式传输</p></li></ol><p>如图所示：</p><img src="/img/imgs/slave.png"><blockquote><p>主从复制风暴</p></blockquote><p>一个主库同时有多个从库连接可能会造成主库压力过大,这时候我们可以选择把这些分散,</p><p>一个主库连接两个从库,其中从库也作为下面的主库,形成一个树状结构</p><h2 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h2><p>主从架构的Redis有一个致命得缺点，如果主节点发生故障之后，无法自动实现故障转移,需要手动的从slave节点中选择一个作为主节点，由此哨兵模式由此而生。</p><blockquote><p>何为哨兵</p></blockquote><p>哨兵就是一个Redis只不过他只起到监控其他Redis得作用,如果主Redis发生故障.那么它会从从库中选择一个作为主节点。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>混合设计模式在项目中的运用</title>
    <link href="/2022/07/05/%E9%9A%8F%E7%AC%94/%E6%B7%B7%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/05/%E9%9A%8F%E7%AC%94/%E6%B7%B7%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="策略-模板-工厂简化项目中的if-else"><a href="#策略-模板-工厂简化项目中的if-else" class="headerlink" title="策略+模板+工厂简化项目中的if-else"></a>策略+模板+工厂简化项目中的if-else</h2><p>最近在做开发的时候,遇到了一个需求：管理员在不同视图下观看到不同的数据</p><p>如果按照以往的开发下使用if-else,不仅在代码上看着臃肿而且还在后续的开发中也难以维护。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(name.equals(<span class="hljs-string">&quot;a&quot;</span>)</span></span>)<br>&#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(name<span class="hljs-selector-class">.equals</span>(<span class="hljs-string">&quot;b&quot;</span>))&#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">if</span>(name<span class="hljs-selector-class">.equals</span>(<span class="hljs-string">&quot;c&quot;</span>)&#123;&#125;<br>.......<br></code></pre></td></tr></table></figure><ol><li><p>首先我们可以把逻辑代码抽象成一个抽象类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Handle</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">InitializingBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> AAA();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后不同逻辑代码实现这个共同的父接口</p></li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZhangSanHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Handle</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AAA</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//子类实现InitializingBean接口的afterPropertiesSet会在初始化Bean的时候执行</span><br>       Factory.register(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建一个工厂类负责生产这些类</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;<span class="hljs-built_in">String</span>,Handle&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Handle <span class="hljs-title function_">getInvokeStrategy</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">get</span>(<span class="hljs-built_in">str</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>,Handle handle)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(StringUtils.<span class="hljs-property">isEmpty</span>(<span class="hljs-built_in">str</span>) || <span class="hljs-literal">null</span> == handle)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">str</span>,handle);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此最原始的代码可以优化为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Handle a <span class="hljs-operator">=</span> Factory.getInvokeStrategy(<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment">;</span><br>a.AAA()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果逻辑代码的业务逻辑大体不同的话,如一个有返回值，一个没有返回值,那么我们只需要把handle改成模板方法即可</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类继承这个模板类实现自己相应的接口即可</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql隔离级别与锁机制</title>
    <link href="/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h3><p>事务是一组SQL语句组成的逻辑单元,事务由以下四个特性。通常被称为ACID</p><ol><li><p>原子性：语句要么全部执行成功，只要一个失败就会返回</p></li><li><p>一致性：事务完成前后，数据保持一致</p></li><li><p>隔离性：一个事务不影响另外一个事务</p></li><li><p>持久性：事务完成之后，对数据的修改是永久的</p></li></ol><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><ul><li><p>脏读：一个事务读取到了另外一个事务还没提交的数据(可能回滚)</p></li><li><p>不可重复读：一个事务中在不同时间段中相同的sql语句获取到了不同的数据</p></li><li><p>幻读：一个事务中在不同时间段中相同的sql语句获取到了个数不同的数据</p></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>乐观锁：根据版本号,如果版本号不匹配重新执行</p></li><li><p>悲观锁：在自己执行的过程中其他事务都不能操作这个数据</p><ul><li><p>表锁：操作时直接锁住整张表,其他不可访问</p></li><li><p>行锁：操作时锁住操作的数据</p></li><li><p>读锁：其他事务可以读,不可以写</p></li><li><p>写锁：不可读写</p></li></ul></li></ul><h3 id="解决并发事务问题"><a href="#解决并发事务问题" class="headerlink" title="解决并发事务问题"></a>解决并发事务问题</h3><ul><li><p>读未提交</p></li><li><p>读已提交(解决脏读)</p></li><li><p>可重复读(解决脏读、不可重复读)</p></li><li><p>串行化(解决脏读、不可重复读、幻读)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Mysql索引</title>
    <link href="/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Mysql索引"><a href="#深入理解Mysql索引" class="headerlink" title="深入理解Mysql索引"></a>深入理解Mysql索引</h1><blockquote><p>索引简介</p></blockquote><p>索引是帮助Mysql高效获取数据的<mark>排好序</mark>的<mark>数据结构</mark></p><p>索引数据结构</p><ul><li><p>hash：不能进行范围查询</p></li><li><p>红黑树</p></li></ul><p>众所周知数据都是存储在磁盘上的。在我们查询数据的时候，会进行磁盘io一条一条数据进行比对,磁盘io速度缓慢,在数据库数据量庞大的时候查询速度会极其缓慢。为了减少磁盘IO,这时候引入索引这个数据结构</p><blockquote><p>聚集索引与非聚集索引</p></blockquote><ul><li><p><mark>聚集索引</mark>：聚集索引就是索引结构和数据库数据的数据分别在同一个文件中,数据全部保存在叶子节点下面</p></li><li><p><mark>非聚集索引</mark>：和聚集索引定义相反,树结构的叶子节点保存的是该数据的磁盘位置</p></li></ul><blockquote><p>红黑树</p></blockquote><p>Mysql数据库中INNODB引擎中默认使用的索引结构是红黑树,所谓红黑树就是二叉树的变种.</p><p>为什么mysql采用红黑树的结构而不是用二叉树呢？</p><p>答：</p><ol><li><p>红黑树相较于二叉树它的非叶子节点不会储存数据</p></li><li><p>红黑树的叶子结点有指针相互引用,在范围搜索的情况下，会提升效率</p></li></ol><p><mark>特点</mark>：数据从左到右递增</p><p>结构如下：</p><p><img src="file:///C:/Users/WS/AppData/Roaming/marktext/images/2022-06-30-17-08-33-image.png" title="" alt="" width="298"><img src="file:///C:/Users/WS/AppData/Roaming/marktext/images/2022-06-30-17-09-04-image.png" title="" alt="" width="334"></p><blockquote><p>红黑树为何能提升效率</p></blockquote><p>搜索数据的时候,首先会先加载第一行的数据进入RAM（内存）中,匹配找到条件的大体位置,往下搜索,重复如上操作。由图可知,例如我们查找主键20的数据,只需要查询三次即可搜索到数据,相较于mysql的全表扫描效率提升极大。</p><blockquote><p>索引覆盖</p></blockquote><p>所谓的索引覆盖就是查询的数据在索引树中可以直接获取到，而不用回表到主键索引聚集表中查询</p><blockquote><p>回表</p></blockquote><p>在索引树中找不到需要的数据,返回到主键索引树中搜索</p><blockquote><p>索引下推</p></blockquote><p>在MYSQL5.6之前，select  * from a  where username like   “a%”  and age &#x3D; 23  在联合索引结构中进行条件搜索时，不会对索引查询的字段(age&#x3D;23)进行判断,会进行回表，在主键索引中进行条件过滤。5.6之后增加了索引下推这个概念,会先根据条件进行过滤</p><blockquote><p>联合索引</p></blockquote><p>MYSQL进行联合索引的创建时,会生成一个非聚集索引结构,默认只能有一个聚集索引即主键索引树。</p><p>例如：username , phone ,age 三个字段为一个联合索引.会先依照username进行排序,如果相等在依照phone进行排序如果相同最后才会以age进行排序.叶子节点储存着对应的id,以便进行回表查询</p><p><img src="C:\Users\WS\AppData\Roaming\marktext\images\2022-06-30-17-38-52-image.png"></p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
